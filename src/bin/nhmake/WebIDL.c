// LICENSE NOTICE ==================================================================================

/**
 * Netzhaut - Web Browser Engine
 * Copyright (C) 2022  Dajo Frey
 * Published under MIT.
 */

// INCLUDE =========================================================================================

#include "WebIDL.h"

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>

// DECLARE =========================================================================================

static NH_BYTE *totalOperations_pp[16384] = {'\0'}; // should suffice
static int totalOperationCount = 0;

// HELPER ==========================================================================================

static void getOutPath(
    NH_BYTE *filepath_p, NH_BYTE *outpath_p)
{
    filepath_p = filepath_p + strlen(filepath_p);
    while (*filepath_p != '/') {filepath_p = filepath_p - 1;}
    filepath_p = filepath_p - 1;
    while (*filepath_p != '/') {filepath_p = filepath_p - 1;}

    sprintf(outpath_p, "src/lib/nhwebidl/Specifications/%s.inc", filepath_p);
}

static NH_MAKE_RESULT getFragmentName(
    NH_BYTE *filepath_p, NH_BYTE *fragmentname_p)
{
    filepath_p = filepath_p + strlen(filepath_p);
    while (*filepath_p != '/') {filepath_p = filepath_p - 1;}
    filepath_p = filepath_p - 1;
    while (*filepath_p != '/') {filepath_p = filepath_p - 1;}
    filepath_p = filepath_p + 1;
    for (int i = 0; strcmp(filepath_p, ".idl"); ++i) {fragmentname_p[i] = *filepath_p; filepath_p = filepath_p + 1;}
    for (int i = 0; i < strlen(fragmentname_p); ++i) {if (fragmentname_p[i] == '/') {fragmentname_p[i] = '_';}}
    return NH_MAKE_SUCCESS;
}

static NH_MAKE_RESULT createIncludes(
    FILE *f, nh_make_ValueArray *IDL_p)
{
    fprintf(f, "// INCLUDE =========================================================================================\n\n");
    fprintf(f, "#include \"Builtin.h\"\n\n");

    for (int i = 0; i < IDL_p->length; ++i) 
    {
        NH_BYTE fragmentName_p[1024] = {'\0'};
        getFragmentName(IDL_p->values_pp[i], fragmentName_p);

        for (int j = 0; j < strlen(fragmentName_p); ++j) {
            if (fragmentName_p[j] == '_') {
                fragmentName_p[j] = '/';
            }
        }

        fprintf(f,"#include \"../Specifications/%s.idl.inc\"\n", fragmentName_p);
    }

    return NH_MAKE_SUCCESS;
}

static NH_MAKE_RESULT createFragmentDataArrays(
    FILE *f, nh_make_ValueArray *IDL_p, int mode)
{
    if (mode == 0) {
        fprintf(f, "\n// FRAGMENT NAMES ==================================================================================\n\n");
        fprintf(f, "NH_BYTE *NH_WEBIDL_FRAGMENT_NAMES_PP[] = {\n");
    }
    else if (mode == 1) {
        fprintf(f, "\n// FRAGMENTS =======================================================================================\n\n");
        fprintf(f, "NH_UNSIGNED_BYTE *NH_WEBIDL_FRAGMENTS_PP[] = {\n");
    }
    else if (mode == 2) {
        fprintf(f, "\n// FRAGMENT LENGTHS =================================================================================\n\n");
        fprintf(f, "const unsigned int NH_WEBIDL_FRAGMENT_LENGTHS_P[] = {\n");
    }

    for (int i = 0; i < IDL_p->length; ++i) 
    {
        NH_BYTE fragmentName_p[1024] = {'\0'}, *p;
        getFragmentName(IDL_p->values_pp[i], fragmentName_p);

        if (mode == 0) {
            fprintf(f, "    \"%s\",\n", fragmentName_p);
        }
        else if (mode == 1) {
            fprintf(f, "    nh_webidl_%s_p,\n", fragmentName_p);
        }
        else if (mode == 2) {
            fprintf(f, "    nh_webidl_%s_p_len,\n", fragmentName_p);
        }
    }

    fprintf(f, "};\n");

    if (mode == 0) {
        fprintf(f, "\nsize_t NH_WEBIDL_FRAGMENT_NAMES_PP_COUNT = sizeof(NH_WEBIDL_FRAGMENT_NAMES_PP) / sizeof(NH_WEBIDL_FRAGMENT_NAMES_PP[0]);\n");
    }
    else if (mode == 1) {
        fprintf(f, "\nsize_t NH_WEBIDL_FRAGMENTS_PP_COUNT = sizeof(NH_WEBIDL_FRAGMENTS_PP) / sizeof(NH_WEBIDL_FRAGMENTS_PP[0]);\n");
    }

    return NH_MAKE_SUCCESS;
}

static NH_MAKE_RESULT createIncludeFile(
    NH_BYTE *runtimePath_p, nh_make_ValueArray *IDL_p)
{
    NH_BYTE filepath_p[1024] = {'\0'};
    sprintf(filepath_p, "%s/Builtin.c", runtimePath_p);

    FILE *f = fopen(filepath_p, "w");
    if (f == NULL) {
        printf("Error opening file!\n");
        exit(1);
    }

#define LICENSE_NOTICE \
    "/**\n * Netzhaut - Web Browser Engine\n * Copyright (C) 2022  Dajo Frey\n * Published under GNU LGPL. See Netzhaut/LICENSE.LGPL file.\n *\n * This file was generated by nhmake\n */\n\n"

    fprintf(f, "// LICENSE NOTICE ==================================================================================\n\n");
    fprintf(f, LICENSE_NOTICE);

    createIncludes(f, IDL_p);
    createFragmentDataArrays(f, IDL_p, 0);
    createFragmentDataArrays(f, IDL_p, 1);
    createFragmentDataArrays(f, IDL_p, 2);

    fclose(f);

    return NH_MAKE_SUCCESS;
}

// HEADER ===========================================================================================

static NH_MAKE_RESULT generateHexDumpFile(
    NH_BYTE *filePath_p, NH_BYTE *fragmentName_p)
{
    NH_BYTE outfilepath_p[1024] = {'\0'};
    getOutPath(filePath_p, outfilepath_p);

    FILE *File_p = fopen(outfilepath_p, "w");
    if (!File_p) {return NH_MAKE_ERROR_BAD_STATE;}

    NH_BYTE name_p[1024] = {'\0'};
    sprintf(name_p, "nh_webidl_%s", fragmentName_p);

    NH_BYTE command_p[1024] = {'\0'};
    sprintf(command_p, "./external/xxd/xxd -i %s %s nh_webidl_%s_p", filePath_p, outfilepath_p, fragmentName_p);

    int status = system(command_p);
    if (WEXITSTATUS(status) || WIFSIGNALED(status)) {return NH_MAKE_ERROR_XXD_EXECUTION_FAILED;}

    fclose(File_p);

    nh_make_messagef("Generate %s", outfilepath_p);

    return NH_MAKE_SUCCESS;
}

// GET OPERATIONS ==================================================================================

static int getFragmentOperations(
    NH_BYTE *filePath_p, NH_BYTE **operations_pp, int *count_p)
{
    // Get file data.
    FILE *fh = fopen(filePath_p, "rb");
    if (fh == NULL) {return 1;}
    
    if (fseek(fh, 0, SEEK_END) != 0) {return 1;}
    long size = ftell(fh);
    rewind(fh);

    if (size <= 0) {
        fclose(fh);
        return 1;
    }

    NH_BYTE *bytes_p = malloc(size+1); 
    if (bytes_p == NULL) {return 1;}
    
    memset(bytes_p, 0, size+1);
    fread(bytes_p, 1, size, fh);
    fclose(fh);

    // Parse.
    int operation = 0;
    for (int i = 0, depth = 0; i < size; ++i) 
    {
             if (bytes_p[i] == '{') {depth++;}
        else if (bytes_p[i] == '}') {depth--;}
        else if (depth > 0) 
        {
            if (bytes_p[i] == '(') 
            {
                bytes_p[i] = '\0';
                int begin = i;
                while (bytes_p[begin] == ' ' && begin > 0) {--begin;}
                while (bytes_p[begin] != ' ' && begin > 0) {--begin;}
                NH_BYTE *operation_p = malloc(sizeof(NH_BYTE) * ((i - begin) + 1));
                if (!operation_p) {return 1;}
                strcpy(operation_p, bytes_p + begin + 1);
                operations_pp[operation++] = operation_p;
                bytes_p[i] = '(';
                while (bytes_p[i] != ';' && i < size) {++i;}
            } 
        }
    }

    *count_p = operation;
    free(bytes_p);

    return 0;
}

// MAIN ============================================================================================

static NH_MAKE_RESULT processWebFragment(
    NH_BYTE *filePath_p, nh_make_ValueArray *IDL_p)
{
    int count = 0;
    if (getFragmentOperations(filePath_p, &totalOperations_pp[totalOperationCount], &count)) {return NH_MAKE_ERROR_BAD_STATE;}
    totalOperationCount += count;

    NH_BYTE fragmentName_p[1024] = {'\0'};
    getFragmentName(filePath_p, fragmentName_p);

    if (generateHexDumpFile(filePath_p, fragmentName_p)
    ||  createIncludeFile("src/lib/nhwebidl/Runtime", IDL_p)) {return NH_MAKE_ERROR_BAD_STATE;}

    return NH_MAKE_SUCCESS;
}

NH_MAKE_RESULT processWebIDL(
    nh_make_Runtime *Runtime_p)
{
    NH_BYTE name_p[1023];
    nh_make_ValueArray ProjDir = nh_make_getVariableValues(Runtime_p, "PROJ_DIR");
    if (!ProjDir.length) {return NH_MAKE_ERROR_BAD_STATE;}

    nh_make_ValueArray IDL = nh_make_getVariableValues(Runtime_p, "IDL");

    for (int i = 0; i < IDL.length; ++i) {
        sprintf(name_p, "%s/%s", ProjDir.values_pp[0], IDL.values_pp[i]);
        if (processWebFragment(name_p, &IDL)) {return NH_MAKE_ERROR_BAD_STATE;}
        memset(name_p, 0, 1023);
    }

    return NH_MAKE_SUCCESS;
} 

